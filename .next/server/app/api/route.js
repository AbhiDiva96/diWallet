"use strict";(()=>{var e={};e.id=755,e.ids=[755],e.modules={20399:e=>{e.exports=require("next/dist/compiled/next-server/app-page.runtime.prod.js")},30517:e=>{e.exports=require("next/dist/compiled/next-server/app-route.runtime.prod.js")},78893:e=>{e.exports=require("buffer")},84770:e=>{e.exports=require("crypto")},17702:e=>{e.exports=require("events")},32615:e=>{e.exports=require("http")},35240:e=>{e.exports=require("https")},21764:e=>{e.exports=require("util")},71568:e=>{e.exports=require("zlib")},33386:(e,t,r)=>{r.r(t),r.d(t,{originalPathname:()=>w,patchFetch:()=>g,requestAsyncStorage:()=>f,routeModule:()=>m,serverHooks:()=>x,staticGenerationAsyncStorage:()=>h});var a={};r.r(a),r.d(a,{POST:()=>d});var n=r(73278),s=r(45002),i=r(54877),o=r(71309),u=r(69747),c=r(31782);let l=new u.Z,p=process.env.NEXTAUTH_SECRET;async function d(e){let t=await (0,c.getToken)({req:e,secret:p});if(!t||"number"!=typeof t.id)return o.NextResponse.json({message:"unauthorised"},{status:401});try{let r=t.id,{amount:a,name:n,type:s}=await e.json();if(!a||!n||!s)return o.NextResponse.json({message:"fields are required"},{status:400});let i=await l.addTransaction(r,a,n,s);return o.NextResponse.json({message:"new transaction added",transaction:i},{status:200})}catch(e){return console.error(e),o.NextResponse.json({message:"You have insufficient balance for this transaction"},{status:500})}}let m=new n.AppRouteRouteModule({definition:{kind:s.x.APP_ROUTE,page:"/api/route",pathname:"/api",filename:"route",bundlePath:"app/api/route"},resolvedPagePath:"E:\\diWallet\\src\\app\\api\\route.ts",nextConfigOutput:"",userland:a}),{requestAsyncStorage:f,staticGenerationAsyncStorage:h,serverHooks:x}=m,w="/api/route";function g(){return(0,i.patchFetch)({serverHooks:x,staticGenerationAsyncStorage:h})}},81643:(e,t,r)=>{r.d(t,{_:()=>a});let a=new(require("@prisma/client")).PrismaClient},69747:(e,t,r)=>{r.d(t,{Z:()=>n});var a=r(81643);class n{async addTransaction(e,t,r,n){let s=await this.getTotalAmount(e);if("expense"===n&&s<t)throw Error("Insufficient balance for this transaction.");let i=await a._.transaction.create({data:{userId:e,amount:t,transactionName:r,type:n}});return await this.updateUserTotalAmount(e,t,n),i}async getTransactions(e){return await a._.transaction.findMany({where:{userId:e},select:{id:!0,amount:!0,type:!0,transactionName:!0,createdAt:!0}})}async calculateTotalAmount(e){let t=0;return e.forEach(e=>{let{amount:r,type:a}=e;"income"===a||"in"===a?t+=r:"expense"===a&&(t-=r)}),t}async getTotalAmount(e){let t=await this.getTransactions(e);return this.calculateTotalAmount(t)}async updateUserTotalAmount(e,t,r){let n=await a._.user.findUnique({where:{id:e},select:{totalAmount:!0}});if(!n)throw Error("User not found");let s=n.totalAmount;if("income"===r||"in"===r)s+=t;else if("expense"===r){if(s>=t)s-=t;else throw Error("Insufficient balance")}return await a._.user.update({where:{id:e},data:{totalAmount:s}}),s}}}};var t=require("../../webpack-runtime.js");t.C(e);var r=e=>t(t.s=e),a=t.X(0,[379,922,309],()=>r(33386));module.exports=a})();