"use strict";(()=>{var e={};e.id=866,e.ids=[866],e.modules={20399:e=>{e.exports=require("next/dist/compiled/next-server/app-page.runtime.prod.js")},30517:e=>{e.exports=require("next/dist/compiled/next-server/app-route.runtime.prod.js")},78893:e=>{e.exports=require("buffer")},84770:e=>{e.exports=require("crypto")},17702:e=>{e.exports=require("events")},32615:e=>{e.exports=require("http")},35240:e=>{e.exports=require("https")},21764:e=>{e.exports=require("util")},71568:e=>{e.exports=require("zlib")},59656:(e,t,r)=>{r.r(t),r.d(t,{originalPathname:()=>x,patchFetch:()=>w,requestAsyncStorage:()=>m,routeModule:()=>d,serverHooks:()=>f,staticGenerationAsyncStorage:()=>h});var a={};r.r(a),r.d(a,{GET:()=>p});var n=r(73278),s=r(45002),o=r(54877),i=r(71309),u=r(31782);let c=new(r(69747)).Z,l=process.env.NEXTAUTH_SECRET;async function p(e){let t=await (0,u.getToken)({req:e,secret:l});if(!t||"number"!=typeof t.id)return i.NextResponse.json({message:"unauthorised"},{status:401});let r=t.id;try{let e=await c.getTotalAmount(r);return i.NextResponse.json({message:"totalAmount you have",totalTransations:e},{status:200})}catch(e){return console.error(),i.NextResponse.json({message:"error while fetching",error:e},{status:500})}}let d=new n.AppRouteRouteModule({definition:{kind:s.x.APP_ROUTE,page:"/api/transactions/route",pathname:"/api/transactions",filename:"route",bundlePath:"app/api/transactions/route"},resolvedPagePath:"E:\\diWallet\\src\\app\\api\\transactions\\route.ts",nextConfigOutput:"",userland:a}),{requestAsyncStorage:m,staticGenerationAsyncStorage:h,serverHooks:f}=d,x="/api/transactions/route";function w(){return(0,o.patchFetch)({serverHooks:f,staticGenerationAsyncStorage:h})}},81643:(e,t,r)=>{r.d(t,{_:()=>a});let a=new(require("@prisma/client")).PrismaClient},69747:(e,t,r)=>{r.d(t,{Z:()=>n});var a=r(81643);class n{async addTransaction(e,t,r,n){let s=await this.getTotalAmount(e);if("expense"===n&&s<t)throw Error("Insufficient balance for this transaction.");let o=await a._.transaction.create({data:{userId:e,amount:t,transactionName:r,type:n}});return await this.updateUserTotalAmount(e,t,n),o}async getTransactions(e){return await a._.transaction.findMany({where:{userId:e},select:{id:!0,amount:!0,type:!0,transactionName:!0,createdAt:!0}})}async calculateTotalAmount(e){let t=0;return e.forEach(e=>{let{amount:r,type:a}=e;"income"===a||"in"===a?t+=r:"expense"===a&&(t-=r)}),t}async getTotalAmount(e){let t=await this.getTransactions(e);return this.calculateTotalAmount(t)}async updateUserTotalAmount(e,t,r){let n=await a._.user.findUnique({where:{id:e},select:{totalAmount:!0}});if(!n)throw Error("User not found");let s=n.totalAmount;if("income"===r||"in"===r)s+=t;else if("expense"===r){if(s>=t)s-=t;else throw Error("Insufficient balance")}return await a._.user.update({where:{id:e},data:{totalAmount:s}}),s}}}};var t=require("../../../webpack-runtime.js");t.C(e);var r=e=>t(t.s=e),a=t.X(0,[379,922,309],()=>r(59656));module.exports=a})();