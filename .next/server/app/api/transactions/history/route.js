"use strict";(()=>{var e={};e.id=196,e.ids=[196],e.modules={20399:e=>{e.exports=require("next/dist/compiled/next-server/app-page.runtime.prod.js")},30517:e=>{e.exports=require("next/dist/compiled/next-server/app-route.runtime.prod.js")},78893:e=>{e.exports=require("buffer")},84770:e=>{e.exports=require("crypto")},17702:e=>{e.exports=require("events")},32615:e=>{e.exports=require("http")},35240:e=>{e.exports=require("https")},21764:e=>{e.exports=require("util")},71568:e=>{e.exports=require("zlib")},78047:(e,t,r)=>{r.r(t),r.d(t,{originalPathname:()=>y,patchFetch:()=>w,requestAsyncStorage:()=>m,routeModule:()=>h,serverHooks:()=>x,staticGenerationAsyncStorage:()=>f});var a={};r.r(a),r.d(a,{GET:()=>d});var s=r(73278),n=r(45002),o=r(54877),i=r(69747),u=r(31782),c=r(71309);let l=process.env.NEXTAUTH_SECRET,p=new i.Z;async function d(e){let t=await (0,u.getToken)({secret:l,req:e});if(!t||"number"!=typeof t.id)return c.NextResponse.json({message:"unathorized"},{status:401});let r=t.id;try{let e=await p.getTransactions(r);return c.NextResponse.json({message:"susseccsully fetched history",accountHistory:e},{status:200})}catch(e){return console.error(),c.NextResponse.json({message:"could find any trantions",error:e},{status:500})}}let h=new s.AppRouteRouteModule({definition:{kind:n.x.APP_ROUTE,page:"/api/transactions/history/route",pathname:"/api/transactions/history",filename:"route",bundlePath:"app/api/transactions/history/route"},resolvedPagePath:"E:\\diWallet\\src\\app\\api\\transactions\\history\\route.ts",nextConfigOutput:"",userland:a}),{requestAsyncStorage:m,staticGenerationAsyncStorage:f,serverHooks:x}=h,y="/api/transactions/history/route";function w(){return(0,o.patchFetch)({serverHooks:x,staticGenerationAsyncStorage:f})}},81643:(e,t,r)=>{r.d(t,{_:()=>a});let a=new(require("@prisma/client")).PrismaClient},69747:(e,t,r)=>{r.d(t,{Z:()=>s});var a=r(81643);class s{async addTransaction(e,t,r,s){let n=await this.getTotalAmount(e);if("expense"===s&&n<t)throw Error("Insufficient balance for this transaction.");let o=await a._.transaction.create({data:{userId:e,amount:t,transactionName:r,type:s}});return await this.updateUserTotalAmount(e,t,s),o}async getTransactions(e){return await a._.transaction.findMany({where:{userId:e},select:{id:!0,amount:!0,type:!0,transactionName:!0,createdAt:!0}})}async calculateTotalAmount(e){let t=0;return e.forEach(e=>{let{amount:r,type:a}=e;"income"===a||"in"===a?t+=r:"expense"===a&&(t-=r)}),t}async getTotalAmount(e){let t=await this.getTransactions(e);return this.calculateTotalAmount(t)}async updateUserTotalAmount(e,t,r){let s=await a._.user.findUnique({where:{id:e},select:{totalAmount:!0}});if(!s)throw Error("User not found");let n=s.totalAmount;if("income"===r||"in"===r)n+=t;else if("expense"===r){if(n>=t)n-=t;else throw Error("Insufficient balance")}return await a._.user.update({where:{id:e},data:{totalAmount:n}}),n}}}};var t=require("../../../../webpack-runtime.js");t.C(e);var r=e=>t(t.s=e),a=t.X(0,[379,922,309],()=>r(78047));module.exports=a})();